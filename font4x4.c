#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <GLFW/glfw3.h>

#include "src/opengl.h"
#include "src/shader.h"

#include "shaders/font_frag.h"
#include "shaders/font_vert.h"

// Building:
// gcc font4x4.c src/opengl.c src/shader.c -std=c99 -DGLFW_INCLUDE_NONE -Ires/ -Isrc/ -Ivendor/include -lGL -lglfw

/*

* each nibble is a line from top to bottom
* each character has a width and height of 1 unit
* a chararacter's x and y are in the center
* kerning is built into the font
* each character has 2 triangles per lit pixel
* each character has 6 vertices per lit pixel
* each vertex has 2 floats (x, y)
* each lit pixel occupies 12 floats (48 bytes)

0xeae0
------

000.
0.0.
000.
....

(-0.5,0.5)   (0.0,0.5)   (0.5,0.5)
     +-----+-----+-----+-----+
     |     |     |     |     |
     | 15  | 14  | 13  | 12  |
     +-----+-----+-----+-----+ (0.5,0.25)
     |     |     |     |     |
     | 11  | 10  |  9  |  8  |
     +-----+-----+-----+-----+ (0.5,0.0)
     |     |     |     |     |
     |  7  |  6  |  5  |  4  |
     +-----+-----+-----+-----+ (0.5,-0.25)
     |     |     |     |     |
     |  3  |  2  |  1  |  0  |
     +-----+-----+-----+-----+
(-0.5,-0.5)  (0.0,-0.5)  (0.5,-0.5)

Each quad is comprised of 2 CCW triangles:

  1     0
  +-----+ 3
  |t1 / |
  |  /  |
  | / t2|
2 +-----+
  4     5

*/

// https://simplifier.neocities.org/4x4.html
static const unsigned short font[] = {
    0xeae0,  // 0
    0x4430,  // 1
    0x2ce0,  // 2
    0xe6e0,  // 3
    0xae20,  // 4
    0xec20,  // 5
    0x8ae0,  // 6
    0xe220,  // 7
    0xeee0,  // 8
    0xea20,  // 9
};

/*

*/

enum {
    QUADS_PER_GLYPH = 16,

    TRIANGLES_PER_QUAD = 2,
    VERTICES_PER_TRIANGLE = 3,
    FLOATS_PER_VERTEX = 2,

    VERTICES_PER_QUAD = TRIANGLES_PER_QUAD * VERTICES_PER_TRIANGLE,
    FLOATS_PER_QUAD = TRIANGLES_PER_QUAD * VERTICES_PER_TRIANGLE * FLOATS_PER_VERTEX,
};

// Generated by:
// python3 scripts/font.py
static const float quads[QUADS_PER_GLYPH][FLOATS_PER_QUAD] = {
    //       top right       top left        bottom left     top right       bottom left     bottom right
    //       x       y       x       y       x       y       x       y       x       y       x       y
    [0]  = {  0.50f, -0.25f,  0.25f, -0.25f,  0.25f, -0.50f,  0.50f, -0.25f,  0.25f, -0.50f,  0.50f, -0.50f },
    [1]  = {  0.25f, -0.25f,  0.00f, -0.25f,  0.00f, -0.50f,  0.25f, -0.25f,  0.00f, -0.50f,  0.25f, -0.50f },
    [2]  = {  0.00f, -0.25f, -0.25f, -0.25f, -0.25f, -0.50f,  0.00f, -0.25f, -0.25f, -0.50f,  0.00f, -0.50f },
    [3]  = { -0.25f, -0.25f, -0.50f, -0.25f, -0.50f, -0.50f, -0.25f, -0.25f, -0.50f, -0.50f, -0.25f, -0.50f },
    [4]  = {  0.50f,  0.00f,  0.25f,  0.00f,  0.25f, -0.25f,  0.50f,  0.00f,  0.25f, -0.25f,  0.50f, -0.25f },
    [5]  = {  0.25f,  0.00f,  0.00f,  0.00f,  0.00f, -0.25f,  0.25f,  0.00f,  0.00f, -0.25f,  0.25f, -0.25f },
    [6]  = {  0.00f,  0.00f, -0.25f,  0.00f, -0.25f, -0.25f,  0.00f,  0.00f, -0.25f, -0.25f,  0.00f, -0.25f },
    [7]  = { -0.25f,  0.00f, -0.50f,  0.00f, -0.50f, -0.25f, -0.25f,  0.00f, -0.50f, -0.25f, -0.25f, -0.25f },
    [8]  = {  0.50f,  0.25f,  0.25f,  0.25f,  0.25f,  0.00f,  0.50f,  0.25f,  0.25f,  0.00f,  0.50f,  0.00f },
    [9]  = {  0.25f,  0.25f,  0.00f,  0.25f,  0.00f,  0.00f,  0.25f,  0.25f,  0.00f,  0.00f,  0.25f,  0.00f },
    [10] = {  0.00f,  0.25f, -0.25f,  0.25f, -0.25f,  0.00f,  0.00f,  0.25f, -0.25f,  0.00f,  0.00f,  0.00f },
    [11] = { -0.25f,  0.25f, -0.50f,  0.25f, -0.50f,  0.00f, -0.25f,  0.25f, -0.50f,  0.00f, -0.25f,  0.00f },
    [12] = {  0.50f,  0.50f,  0.25f,  0.50f,  0.25f,  0.25f,  0.50f,  0.50f,  0.25f,  0.25f,  0.50f,  0.25f },
    [13] = {  0.25f,  0.50f,  0.00f,  0.50f,  0.00f,  0.25f,  0.25f,  0.50f,  0.00f,  0.25f,  0.25f,  0.25f },
    [14] = {  0.00f,  0.50f, -0.25f,  0.50f, -0.25f,  0.25f,  0.00f,  0.50f, -0.25f,  0.25f,  0.00f,  0.25f },
    [15] = { -0.25f,  0.50f, -0.50f,  0.50f, -0.50f,  0.25f, -0.25f,  0.50f, -0.50f,  0.25f, -0.25f,  0.25f },
};

long
font_size(const char* s)
{
    assert(s != NULL);
    long size = 0;

    char c;
    while ((c = *s++) != '\0') {
        c = c - '0';
        assert(c >= 0 && c <= 9);

        unsigned short glyph = font[c];
        for (long i = 0; i < 4*4; i++) {
            char quad = (glyph >> i) & 1;
            if (quad) {
                size += FLOATS_PER_QUAD * sizeof(float);
            }
        }
    }

    return size;
}

long
font_vertices(const char* s)
{
    assert(s != NULL);
    long vertices = 0;

    char c;
    while ((c = *s++) != '\0') {
        c = c - '0';
        assert(c >= 0 && c <= 9);

        unsigned short glyph = font[c];
        for (long i = 0; i < 4*4; i++) {
            char quad = (glyph >> i) & 1;
            if (!quad) continue;

            vertices += VERTICES_PER_QUAD;
        }
    }

    return vertices;
}

void
font_print(const char* s, float* b, long size)
{
    assert(s != NULL);
    assert(b != NULL);
    assert(size >= font_size(s));

    long x = 0;
    long y = 0;

    char c;
    while ((c = *s++) != '\0') {
        c = c - '0';
        assert(c >= 0 && c <= 9);

        unsigned short glyph = font[c];
        for (long i = 0; i < 4*4; i++) {
            char quad = (glyph >> i) & 1;
            if (!quad) continue;

            for (long v = 0; v < VERTICES_PER_QUAD; v++) {
                *b++ = quads[i][v*2 + 0] + x;
                *b++ = quads[i][v*2 + 1] + y;
            }
        }

        x += 1;
    }
}


int
main(int argc, char* argv[])
{
    if (!glfwInit()) {
        const char* error = NULL;
        glfwGetError(&error);
        fprintf(stderr, "failed to init GLFW3: %s\n", error);
        return EXIT_FAILURE;
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);

    GLFWwindow* window = glfwCreateWindow(500, 500, "4x4 Font Example", NULL, NULL);
    if (window == NULL) {
        const char* error = NULL;
        glfwGetError(&error);
        fprintf(stderr, "failed to create GLFW3 window: %s\n", error);

        glfwTerminate();
        return EXIT_FAILURE;
    }

    glfwMakeContextCurrent(window);
    opengl_load_functions();

    unsigned shader = shader_compile_and_link(SHADER_FONT_VERT_SOURCE, SHADER_FONT_FRAG_SOURCE);

    const char str[] = "042";
    long size = font_size(str);
    long vertices = font_vertices(str);
    printf("size:  %ld\n", size);
    printf("verts: %ld\n", vertices);

    float* buf = malloc(size);
    font_print(str, buf, size);

    for (long i = 0; i < vertices / 3; i++) {
        printf("(%f,%f) (%f,%f) (%f,%f)\n",
            buf[i*6 + 0], buf[i*6 + 1],
            buf[i*6 + 2], buf[i*6 + 3],
            buf[i*6 + 4], buf[i*6 + 5]);
    }

    unsigned vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);

    unsigned vbo;
    glGenBuffers(1, &vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);

    glBufferData(GL_ARRAY_BUFFER, size, buf, GL_STATIC_DRAW);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, (const void*)0);
    glEnableVertexAttribArray(0);

    free(buf);

    printf("OpenGL Vendor:   %s\n", glGetString(GL_VENDOR));
    printf("OpenGL Renderer: %s\n", glGetString(GL_RENDERER));
    printf("OpenGL Version:  %s\n", glGetString(GL_VERSION));
    printf("GLSL Version:    %s\n", glGetString(GL_SHADING_LANGUAGE_VERSION));

    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

    while (!glfwWindowShouldClose(window)) {
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
            glfwSetWindowShouldClose(window, GLFW_TRUE);
        }

        glViewport(0.0f, 0.0f, 500.0f, 500.0f);
        glClearColor(0.2f, 0.3f, 0.4f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        glUseProgram(shader);
        glBindVertexArray(vao);
        glDrawArrays(GL_TRIANGLES, 0, vertices);

        glfwSwapBuffers(window);
        glfwPollEvents();
    } 

    glDeleteProgram(shader);
    glDeleteBuffers(1, &vbo);
    glDeleteVertexArrays(1, &vao);

    glfwDestroyWindow(window);
    glfwTerminate();

    return EXIT_SUCCESS;
}
