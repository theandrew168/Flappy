#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <GLFW/glfw3.h>

#include "src/opengl.h"
#include "src/shader.h"

#include "shaders/font_frag.h"
#include "shaders/font_vert.h"

// Building:
// gcc font4x4.c src/opengl.c src/shader.c -std=c99 -DGLFW_INCLUDE_NONE -Ires/ -Isrc/ -Ivendor/include -lGL -lglfw

/*
0000 0
0001 1
0010 2
0011 3 
0100 4
0101 5
0110 6
0111 7
1000 8
1001 9
1010 a
1011 b
1100 c
1101 d
1110 e
1111 f

0 -> 0xeae0:

000.
0.0.
000.
....

*/

// each nibble is a line from top to bottom
// each character has a width and height of 1 unit
// a chararacter's x and y are in the center
// kerning is built into the font
// each character has 2 triangles per lit pixel
// each character has 6 vertices per lit pixel
// each vertex has 2 floats (x, y)
// each lit pixel occupies 12 floats (48 bytes)
static const unsigned short font[] = {
    0xeae0,  // 0
    0x4430,  // 1
    0x2ce0,  // 2
    0xe6e0,  // 3
    0xae20,  // 4
    0xec20,  // 5
    0x8ae0,  // 6
    0xe220,  // 7
    0xeee0,  // 8
    0xea20,  // 9
};

/*

(-0.5,0.5)   (0.0,0.5)   (0.5,0.5)
     +-----+-----+-----+-----+
     |     |     |     |     |
     | 15  | 14  | 13  | 12  |
     +-----+-----+-----+-----+ (0.5,0.25)
     |     |     |     |     |
     | 11  | 10  |  9  |  8  |
     +-----+-----+-----+-----+ (0.5,0.0)
     |     |     |     |     |
     |  7  |  6  |  5  |  4  |
     +-----+-----+-----+-----+ (0.5,-0.25)
     |     |     |     |     |
     |  3  |  2  |  1  |  0  |
     +-----+-----+-----+-----+
(-0.5,-0.5)  (0.0,-0.5)  (0.5,-0.5)

*/

enum {
    QUADS_PER_GLYPH = 16,

    TRIANGLES_PER_QUAD = 2,
    VERTICES_PER_TRIANGLE = 3,
    FLOATS_PER_VERTEX = 2,

    FLOATS_PER_QUAD = TRIANGLES_PER_QUAD * VERTICES_PER_TRIANGLE * FLOATS_PER_VERTEX,
};

// Generated by:
// python3 scripts/font.py
static const float quads[QUADS_PER_GLYPH][FLOATS_PER_QUAD] = {
    //       top right       top left        bottom left     top right       bottom left     bottom right
    //       x       y       x       y       x       y       x       y       x       y       x       y
    [0]  = {  0.50f, -0.25f,  0.25f, -0.25f,  0.25f, -0.50f,  0.50f, -0.25f,  0.25f, -0.50f,  0.50f, -0.50f },
    [1]  = {  0.25f, -0.25f,  0.00f, -0.25f,  0.00f, -0.50f,  0.25f, -0.25f,  0.00f, -0.50f,  0.25f, -0.50f },
    [2]  = {  0.00f, -0.25f, -0.25f, -0.25f, -0.25f, -0.50f,  0.00f, -0.25f, -0.25f, -0.50f,  0.00f, -0.50f },
    [3]  = { -0.25f, -0.25f, -0.50f, -0.25f, -0.50f, -0.50f, -0.25f, -0.25f, -0.50f, -0.50f, -0.25f, -0.50f },
    [4]  = {  0.50f,  0.00f,  0.25f,  0.00f,  0.25f, -0.25f,  0.50f,  0.00f,  0.25f, -0.25f,  0.50f, -0.25f },
    [5]  = {  0.25f,  0.00f,  0.00f,  0.00f,  0.00f, -0.25f,  0.25f,  0.00f,  0.00f, -0.25f,  0.25f, -0.25f },
    [6]  = {  0.00f,  0.00f, -0.25f,  0.00f, -0.25f, -0.25f,  0.00f,  0.00f, -0.25f, -0.25f,  0.00f, -0.25f },
    [7]  = { -0.25f,  0.00f, -0.50f,  0.00f, -0.50f, -0.25f, -0.25f,  0.00f, -0.50f, -0.25f, -0.25f, -0.25f },
    [8]  = {  0.50f,  0.25f,  0.25f,  0.25f,  0.25f,  0.00f,  0.50f,  0.25f,  0.25f,  0.00f,  0.50f,  0.00f },
    [9]  = {  0.25f,  0.25f,  0.00f,  0.25f,  0.00f,  0.00f,  0.25f,  0.25f,  0.00f,  0.00f,  0.25f,  0.00f },
    [10] = {  0.00f,  0.25f, -0.25f,  0.25f, -0.25f,  0.00f,  0.00f,  0.25f, -0.25f,  0.00f,  0.00f,  0.00f },
    [11] = { -0.25f,  0.25f, -0.50f,  0.25f, -0.50f,  0.00f, -0.25f,  0.25f, -0.50f,  0.00f, -0.25f,  0.00f },
    [12] = {  0.50f,  0.50f,  0.25f,  0.50f,  0.25f,  0.25f,  0.50f,  0.50f,  0.25f,  0.25f,  0.50f,  0.25f },
    [13] = {  0.25f,  0.50f,  0.00f,  0.50f,  0.00f,  0.25f,  0.25f,  0.50f,  0.00f,  0.25f,  0.25f,  0.25f },
    [14] = {  0.00f,  0.50f, -0.25f,  0.50f, -0.25f,  0.25f,  0.00f,  0.50f, -0.25f,  0.25f,  0.00f,  0.25f },
    [15] = { -0.25f,  0.50f, -0.50f,  0.50f, -0.50f,  0.25f, -0.25f,  0.50f, -0.50f,  0.25f, -0.25f,  0.25f },
};

long
font_size(const char* s)
{
    assert(s != NULL);
    long size = 0;

    char c;
    while ((c = *s++) != '\0') {
        c = c - '0';
        assert(c >= 0 && c <= 9);

        unsigned short glyph = font[c];
        for (long i = 0; i < 4*4; i++) {
            char quad = (glyph >> i) & 1;
            if (quad) {
                size += FLOATS_PER_QUAD * sizeof(float);
            }
        }
    }

    return size;
}

long
font_triangles(const char* s)
{
    assert(s != NULL);
    long triangles = 0;

    char c;
    while ((c = *s++) != '\0') {
        c = c - '0';
        assert(c >= 0 && c <= 9);

        unsigned short glyph = font[c];
        for (long i = 0; i < 4*4; i++) {
            char quad = (glyph >> i) & 1;
            if (quad) {
                triangles += TRIANGLES_PER_QUAD;
            }
        }
    }

    return triangles;
}

void
font_print(const char* s, float* b, long size)
{
    assert(s != NULL);
    assert(b != NULL);
    assert(size >= font_size(s));

    long x = 0;
    long y = 0;

    char c;
    while ((c = *s++) != '\0') {
        c = c - '0';
        assert(c >= 0 && c <= 9);

        unsigned short glyph = font[c];
        for (long i = 0; i < 4*4; i++) {
            char quad = (glyph >> i) & 1;
            if (quad) {
                memcpy(b, quads[i], FLOATS_PER_QUAD * sizeof(float));
                b += FLOATS_PER_QUAD;
            }
        }
    }
}


int
main(int argc, char* argv[])
{
    if (!glfwInit()) {
        const char* error = NULL;
        glfwGetError(&error);
        fprintf(stderr, "failed to init GLFW3: %s\n", error);
        return EXIT_FAILURE;
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE);

    GLFWwindow* window = glfwCreateWindow(500, 500, "4x4 Font Example", NULL, NULL);
    if (window == NULL) {
        const char* error = NULL;
        glfwGetError(&error);
        fprintf(stderr, "failed to create GLFW3 window: %s\n", error);

        glfwTerminate();
        return EXIT_FAILURE;
    }

    glfwMakeContextCurrent(window);
    opengl_load_functions();

    unsigned shader = shader_compile_and_link(SHADER_FONT_VERT_SOURCE, SHADER_FONT_FRAG_SOURCE);

    //const char str[] = "042";
    const char str[] = "0";
    long size = font_size(str);
    long triangles = font_triangles(str);
    printf("size: %ld\n", size);
    printf("tris: %ld\n", triangles);

    float* buf = malloc(size);
    font_print(str, buf, size);

    for (long i = 0; i < triangles; i++) {
        printf("(%f,%f) (%f,%f) (%f,%f)\n",
            buf[i*6 + 0], buf[i*6 + 1],
            buf[i*6 + 2], buf[i*6 + 3],
            buf[i*6 + 4], buf[i*6 + 5]);
    }

    unsigned vbo;
    glGenBuffers(1, &vbo);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glBufferData(GL_ARRAY_BUFFER, size, buf, GL_STATIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    unsigned vao;
    glGenVertexArrays(1, &vao);
    glBindVertexArray(vao);
    glBindBuffer(GL_ARRAY_BUFFER, vbo);
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, (const void*)0);
    glEnableVertexAttribArray(0);
    glBindVertexArray(0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    free(buf);

    printf("OpenGL Vendor:   %s\n", glGetString(GL_VENDOR));
    printf("OpenGL Renderer: %s\n", glGetString(GL_RENDERER));
    printf("OpenGL Version:  %s\n", glGetString(GL_VERSION));
    printf("GLSL Version:    %s\n", glGetString(GL_SHADING_LANGUAGE_VERSION));

    //glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);

    while (!glfwWindowShouldClose(window)) {
        if (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS) {
            glfwSetWindowShouldClose(window, GLFW_TRUE);
        }

        glViewport(-0.5f, -0.5f, 1.0f, 1.0f);
        glClearColor(0.2f, 0.3f, 0.4f, 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        glUseProgram(shader);
        glBindVertexArray(vao);
        glDrawArrays(GL_TRIANGLES, 0, triangles * 3);
        glBindVertexArray(0);
        glUseProgram(0);

        glfwSwapBuffers(window);
        glfwPollEvents();
    } 

    glDeleteProgram(shader);
    glDeleteBuffers(1, &vbo);
    glDeleteVertexArrays(1, &vao);

    glfwDestroyWindow(window);
    glfwTerminate();

    return EXIT_SUCCESS;
}
